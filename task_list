PICKED TASKS

 * build numeric_reader_interface
 * define it as
   struct numeric_reader_interface
   {
      const void* context;
      int (*is_valid)(numeric_reader_interface* nri_p);
      int (*is_null)(numeric_reader_interface* nri_p);
      void (*extract_sign_bits_and_exponent)(numeric_reader_interface* nri_p, numeric_sign_bits* sign_bits, int16_t* exponent);
      uint32_t (*read_digits_as_stream)(numeric_reader_interface* nri_p, uint64_t* digits, uint32_t digits_size, int* error);
      void (*close_digits_stream)(numeric_reader_interface* nri_p);
   };

 * implement binary_reader_interface using binary_read_iterator AND a user_value
 * implement binary_reader_interface using digit_read_iterator AND a MATERIALIZED_NUMERIC (*in future)

 * refactor comparator and hasher to to use these interfaces instead

* JSONB
  * uses JSONparser's node as input object
  * allows us to serialize it as per the design of this project
  * generates binary_reader_interface and numeric_reader_interface on text and number types
  * first byte says type
    0 -> NULL
    1 -> true
    2 -> false
    3 -> string -> 4 byte size (>= 4), and then the bytes
    4 -> numeric -> 4 byte size (always 4 + 4*Ndigits + 3), 1 byte sign bits, 2 bytes exponent, then digits
    5 -> json array -> 4 byte size (>= 8), 4 byte element count, then elements
    6 -> json object -> 4 byte size (>= 8), 4 byte element count (always a multiple of 2, key then values), then keys and values alternatively, keys are always strings and ordered lexicographically

future tasks

MATERIALIZED NUMERIC
  * we also need a materialized struct to store all the digits (base 10^12)
    * struct stores uint sign_bits:2, int64_t exponent, and then a value array list of uint64_t digits
    * add functions like push least significant digit, add most significant digit (also changes exponent) and modify/get nth digit
    * write a complete briefcase of functions to perform add, sub, multiplication and division, compare and min, max functions