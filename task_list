PICKED TASKS

* define struct jsonb in-memory representation object using bst and array using arraylist, also an enum of jsonb type
  * number using materialized_numeric and strings and keys using dstring
typedef enum jsonb_type jsonb_type;
enum jsonb_type
{
    JSONB_NULL = 0,
    JSONB_TRUE = 1,
    JSONB_FALSE = 2,
    JSONB_STRING = 3,
    JSONB_NUMERIC = 4,
    JSONB_ARRAY = 5,
    JSONB_OBJECT = 6,
};
typedef struct jsonb_node jsonb_node;
// node = NULL is same as JSONB_NULL node
struct jsonb_node
{
  jsonb_type type; // NULL, true and false encapsulated here, and there will be static jsonb_node for that
  union
  {
    dstring string_value;
    materialized_numeric numeric_value;
    bst jsonb_object;
    arraylist jsonb_array;
  };
};
typedef struct jsonb_object_entry jsonb_object_entry;
struct jsonb_object_entry
{
  dstring key;
  jsonb_node* value;

  bstnode jsonb_object_node;
};
* build functions to get json node for respective types
* build functions to delete jsonb_node
* build functions to clone jsonb_node
* intiialize jsonb write_iterator to write the jsonb struct using the underlying binary_write_iterator

* define a container to store all json b accessor and their corresponding binary_read_iterator to start parsing from
* need a function to normalize all jsonb accessors, sorting them, removing duplicates, removing all accessors that are contained inside th another one
* need a function to iterate over all of jsonb_extended and build binary iterators to parse each one

* JSONB
  * first byte says type
    0 -> NULL
    1 -> true
    2 -> false
    3 -> string -> 4 byte size (>= 4), and then the bytes
    4 -> numeric -> 4 byte size (always 4 + 4*Ndigits + 3), 1 byte sign bits, 2 bytes exponent, then digits
    5 -> json array -> 4 byte size (>= 8), 4 byte element count, then elements
    6 -> json object -> 4 byte size (>= 8), 4 byte element count (always a multiple of 2, key then values), then keys and values alternatively, keys are always strings and ordered lexicographically
  * uses JSONparser's node as input object
    * build a helper function to serialize json_node and write it to a open binary_write_iterator
  * allows opening a binary_read_iterator on it using a json_accessor (from JSONparser library), which is first sorted and then elements with are prefixes to some other json_accessor, then some other are eliminated
   * we will allow partial parsing
   * function to check if the current object being pointed to is of what type using the first byte
   * generates text_reader_interface and numeric_reader_interface on text and numeric types
   * allows materializing the current object being pointer to into a json_node
   * json_node then allows equality, contains, union, intersection and difference
  * build jsonb_node from json_node and viceversa
  * add hasher to hash some attribute nestedly


(*future)
materialized_numeric
  * write a complete briefcase of functions to perform add, sub, multiplication and division