
 * Implement the below functions as templated macros, so their usage is common between all of text, blob, numeric and json
  * hash -> first hash the prefix as is, then hash all the bytes from the following worm
  * using the corresponding read write iterators
    * compare -> read iterators on both a and b -> compare until the 1st one vanishes -> return a - b -> for heap table
    * generate_prefix -> read iterator on the larger one and write on the shorter one -> to be used for indexes -> 1 if a is prefix of b, 2 if they are equal, 0 otherwise
    * is_prefix -> read on both on them, until the shorter one is completely read -> checking for indexes

 * LARGE_NUMERIC
  * also make function to compare only using sign bits and exponent first
  s1, e1, s2, e2 -> ine compare => (std -1, 0, 1 and -2 for inconclusive)
  int compare_up_until = 0;
  compare_up_until = compare_numbers(s1, s2);
  if(s1 == 0 || s1 == 3 || s2 == 0 || s2 == 3) // if anything is infinity we are done
    return compare_up_until;
  if(compare_up_until != 0)
    return compare_up_until;
  // you reach here only if both are non-infinity and are either both positiove or both negative
  compare_up_until = compare_numbers(e1, e2);
  if(compare_up_until != 0)
    return compare_up_until;
  return -2;

  * need a read/write iterator to read/write digits in order first from prefix then from the worm
  * api will read/write digits in to a buffer holding digits in a array of uint64_t[], each digit is a base 10^12 number

  * we also need a materialized struct to store all the digits (base 10^12)
    * struct stores uint sign_bits:2, int64_t exponent, and then a value array list of uint64_t digits
    * add functions like push least significant digit, add most significant digit (also changes exponent) and modify/get nth digit
    * write a complete briefcase of functions to perform add, sub, multiplication and division, compare and min, max functions

* LARGE_JSONB
  * get -> takes var array of integers and string and makes you point to the beginning of the data in json struct
  * build a one direction readabale json serialization type, where we only need to go forward until we reach the desired type
  * create_worm
  * uses JSONparser's node as input object